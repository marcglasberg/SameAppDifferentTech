// Generated by Celest. This file should not be modified manually, but
// it can be checked into version control.
// ignore_for_file: type=lint, unused_local_variable, unnecessary_cast, unnecessary_import

library; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:convert' as _$convert;

import 'package:async_redux_core/src/user_exception.dart' as _$user_exception;
import 'package:celest/celest.dart';
import 'package:celest_backend/my_src/models/available_stock.dart'
    as _$available_stock;
import 'package:celest_backend/my_src/models/cash_balance.dart'
    as _$cash_balance;
import 'package:celest_backend/my_src/models/portfolio.dart' as _$portfolio;
import 'package:celest_backend/my_src/models/stock.dart' as _$stock;
import 'package:celest_core/src/exception/cloud_exception.dart';
import 'package:celest_core/src/exception/serialization_exception.dart';
import 'package:fast_immutable_collections/src/ilist/ilist.dart' as _$ilist;

import '../../client.dart';

class CelestFunctions {
  final admin = CelestFunctionsAdmin();

  final database = CelestFunctionsDatabase();

  final portfolio = CelestFunctionsPortfolio();

  final stocks = CelestFunctionsStocks();
}

class CelestFunctionsAdmin {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'UserException':
        throw Serializers.instance
            .deserialize<_$user_exception.UserException>($details);
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> doSomething() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/admin/do-something'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> setDatabase(
    _$portfolio.Portfolio portfolio,
    Iterable<_$available_stock.AvailableStock> availableStocks,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/admin/set-database'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'portfolio':
            Serializers.instance.serialize<_$portfolio.Portfolio>(portfolio),
        r'availableStocks': availableStocks
            .map((el) => Serializers.instance
                .serialize<_$available_stock.AvailableStock>(el))
            .toList(),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsDatabase {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// This cloud function can be accessed with `celest.functions.database.init();`
  /// I'm using the init function to simulate the database initialization.
  /// In reality this would be an admin service that connects to a third-party stock price provider.
  Future<void> init() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/database/init'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsPortfolio {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'UserException':
        throw Serializers.instance
            .deserialize<_$user_exception.UserException>($details);
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// Reads the portfolio from the database. This includes the cash balance and the stocks.
  Future<_$portfolio.Portfolio> readPortfolio() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/read-portfolio'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$portfolio.Portfolio>($body['response']);
  }

  /// Reads the cash balance from the database.
  Future<_$cash_balance.CashBalance> readCashBalance() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/read-cash-balance'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$cash_balance.CashBalance>($body['response']);
  }

  /// When the user presses the "+" button to add cash, this function is called.
  Future<_$cash_balance.CashBalance> addCashBalance(double howMuch) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/add-cash-balance'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'howMuch': howMuch}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$cash_balance.CashBalance>($body['response']);
  }

  /// When the user presses the "-" button to remove cash, this function is called.
  Future<_$cash_balance.CashBalance> removeCashBalance(double howMuch) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/remove-cash-balance'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'howMuch': howMuch}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$cash_balance.CashBalance>($body['response']);
  }

  /// Buys the given [availableStock] and return the [Stock] bought.
  /// This may thrown the same [UserException]s thrown by [Portfolio].
  ///
  Future<({_$cash_balance.CashBalance cashBalance, _$stock.Stock stock})>
      buyStock(
    _$available_stock.AvailableStock availableStock, {
    required int howMany,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/buy-stock'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'availableStock': Serializers.instance
            .serialize<_$available_stock.AvailableStock>(availableStock),
        r'howMany': howMany,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          _$cash_balance.CashBalance cashBalance,
          _$stock.Stock stock
        })>($body['response']);
  }

  /// Sells the given [availableStock] and return the [Stock] bought.
  /// Returns a Stock with `howManyShares` zero and `averagePrice` zero if all the stock was sold.
  /// This may thrown the same [UserException]s thrown by [Portfolio].
  ///
  Future<({_$cash_balance.CashBalance cashBalance, _$stock.Stock stock})>
      sellStock(
    _$available_stock.AvailableStock availableStock, {
    required int howMany,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/portfolio/sell-stock'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'availableStock': Serializers.instance
            .serialize<_$available_stock.AvailableStock>(availableStock),
        r'howMany': howMany,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          _$cash_balance.CashBalance cashBalance,
          _$stock.Stock stock
        })>($body['response']);
  }
}

class CelestFunctionsStocks {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$ilist.IList<_$available_stock.AvailableStock>>
      readAvailableStocks() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/stocks/read-available-stocks'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$ilist.IList<_$available_stock.AvailableStock>>(
            $body['response']);
  }

  /// This function selects a random ticker, updates its price (with some random variation)
  /// and returns the updated ticker/price pair.
  ///
  /// For the moment, Celest has no features to read directly from a database with a websocket,
  /// so I've created this functions to help me simulate this. As soon as Celest has websockets to
  /// the database I'm going to remove this function and replace it with the real thing.
  ///
  /// Note I'll also have to simulate the websocket client in the frontend code, to use
  /// this function and convert it to a stream of values.
  ///
  Future<({double price, String ticker})?> readUpdatedStockPrice() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/stocks/read-updated-stock-price'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<({double price, String ticker})?>($body['response']);
  }
}
